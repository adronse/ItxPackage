input AcceptTeamInviteInput {
  inviteId: ID!
}

type ActionCreatedEvent {
  userId: ID!
  action: UserAction!
}

"""A connection to a list of items."""
type ActivityLogConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ActivityLogEdge!]

  """A flattened list of the nodes."""
  nodes: [IssueActivityLog!]

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type ActivityLogEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: IssueActivityLog!
}

interface Actor {
  actorId: ID!
  displayName: String!
}

scalar Any

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
  VALIDATION
}

type AsanaConnection {
  workspaces: [AsanaWorkspace!]!
  teams(workspaceId: String!): [AsanaTeam!]!
  projects(workspaceId: String!, teamId: String!): [AsanaProject!]!
  assignableUsers(workspaceId: String!, teamId: String!): [AsanaUser!]!
  id: ID!
}

type AsanaProject {
  name: String!
  gid: String!
  resourceType: String!
}

type AsanaTeam {
  name: String!
  gid: String!
  resourceType: String!
}

type AsanaUser {
  name: String!
  photo: AsanaUserPhoto!
  email: String!
  gid: String!
  resourceType: String!
}

type AsanaUserPhoto {
  image: String!
}

type AsanaWorkspace {
  name: String!
  gid: String!
  resourceType: String!
}

type Attachment {
  user: User!
  url: String!
  filename: String!
  contentType: String!
  type: AttachmentType!
  status: IssueAttachmentStatus!
  createdAt: DateTime!
  id: ID!
}

input AttachmentFilterInput {
  and: [AttachmentFilterInput!]
  or: [AttachmentFilterInput!]
  url: StringOperationFilterInput
  filename: StringOperationFilterInput
  contentType: StringOperationFilterInput
  type: AttachmentTypeOperationFilterInput
  status: IssueAttachmentStatusOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  id: LongOperationFilterInput
}

input AttachmentSortInput {
  url: SortEnumType
  filename: SortEnumType
  contentType: SortEnumType
  type: SortEnumType
  status: SortEnumType
  createdAt: SortEnumType
  id: SortEnumType
}

enum AttachmentType {
  SCREENSHOT
  ATTACHMENT
  PROCESSED_SCREENSHOT
  VIDEO
}

input AttachmentTypeOperationFilterInput {
  eq: AttachmentType
  neq: AttachmentType
  in: [AttachmentType!]
  nin: [AttachmentType!]
}

type Avatar {
  url: String
  color: RgbaColor!
}

input AvatarFilterInput {
  and: [AvatarFilterInput!]
  or: [AvatarFilterInput!]
  url: StringOperationFilterInput
  color: RgbaColorFilterInput
}

input AvatarSortInput {
  url: SortEnumType
  color: RgbaColorSortInput
}

input Base64UploadInput {
  content: String!
  filename: String!
  contentType: String!
  contentDisposition: String
}

enum BillingFrequency {
  MONTHLY
  YEARLY
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

type CardPaymentMethod {
  last4: String!
  brand: String!
}

enum ChromeAppOnboarding {
  STARTED
  DONE
}

input ConsoleLogRecordInput {
  message: String!
  sourceFile: String!
  type: IssueConsoleLogsType!
  timestamp: DateTime!
}

input CreateEmptyIssueInput {
  projectId: ID!
  preSignedBlob: PreSignedBlobInput
  title: String!
  priority: IssuePriority
  labelIds: [ID]
  statusId: ID
  description: String
  assigneeId: ID
}

input CreateIssueAttachmentInput {
  issueId: ID!
  attachment: PreSignedBlobInput!
}

input CreateIssueCommentInput {
  issueId: ID!
  richText: JSON
  text: String
  htmlText: String
}

input CreateIssueCommentReactionInput {
  messageId: ID!
  name: String!
}

input CreateOAuthAuthorizationInput {
  clientId: String!
  redirectUri: String!
  state: String!
}

input CreateProjectInput {
  name: String!
  teamId: ID!
}

input CreateProjectIntegrationConnectionInput {
  projectId: ID!
  connectionId: ID!
  settings: JSON
}

input CreateProjectMembershipInput {
  memberId: ID!
  projectId: ID!
}

input CreateProjectWebIssueInput {
  projectId: ID!
  url: String!
  screenshot: Base64UploadInput
  preSignedBlob: PreSignedBlobInput
  userAgent: String!
  locale: String!
  pageTitle: String!
  elements: [ElementInput!]!
  openGraphTags: [OpenGraphTagInput!]!
  networkRecords: [NetworkRecordInput!]!
  consoleLogRecords: [ConsoleLogRecordInput!]!
  title: String!
  priority: IssuePriority
  labelIds: [ID]
  statusId: ID
  description: String
  assigneeId: ID
}

input CreateTeamInput {
  name: String!
  description: String!
  invites: String!
}

input CreateTeamInviteInput {
  teamId: ID!
  role: MembershipRole!
  emails: [String!]!
}

input CreateTeamLabelInput {
  teamId: ID!
  name: String!
  color: String!
}

input CreateTeamProjectInput {
  teamId: ID!
  name: String!
  url: String!
}

input CreateTeamStatusInput {
  teamId: ID!
  name: String!
  color: String!
  category: StatusCategory!
}

input CreateWebProjectInput {
  url: String!
  screenshot: Base64UploadInput
  faviconUrl: String
  language: String
  userAgent: String
  name: String!
  teamId: ID!
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input DeleteIssueAttachmentInput {
  attachmentId: ID!
}

input DeleteIssueCommentInput {
  messageId: ID!
}

input DeleteIssueCommentReactionInput {
  messageId: ID!
  name: String!
}

input DeleteProjectIntegrationConnectionInput {
  projectId: ID!
  connectionId: ID!
}

input DeleteProjectMembershipInput {
  memberId: ID!
  projectId: ID!
}

input DeleteTeamInviteInput {
  inviteId: ID!
  teamId: ID!
}

input DeleteTeamLabelInput {
  labelId: ID!
  teamId: ID!
}

input DeleteTeamMembershipInput {
  teamId: ID!
  memberId: ID!
}

input DeleteTeamStatusInput {
  statusId: ID!
  teamId: ID!
}

input DomNodeInput {
  cssSelector: String!
  xPath: String!
  size: RectangleInput!
  pagePosition: PointInput!
  clickPosition: PointInput!
  viewportPosition: PointInput!
  viewportSize: RectangleInput!
  pageSize: RectangleInput!
}

input ElementInput {
  tagName: String!
  node: DomNodeInput!
  css: JSON
  html: String!
}

type ExternalAssignee {
  avatarUrl: String
  name: String!
}

input ExternalAssigneeFilterInput {
  and: [ExternalAssigneeFilterInput!]
  or: [ExternalAssigneeFilterInput!]
  avatarUrl: StringOperationFilterInput
  name: StringOperationFilterInput
}

type Features {
  manageTeam: FeatureStatus!
  createProject: FeatureStatus!
  createIssue: FeatureStatus!
  captureVideoIssue: FeatureStatus!
  createLabel: FeatureStatus!
  createStatus: FeatureStatus!
  addAttachment: FeatureStatus!
  projectPrivacy: FeatureStatus!
  autoIntegrateCapturedIssues: FeatureStatus!
  advancedCaptureIssues: FeatureStatus!
}

enum FeatureStatus {
  UNAUTHORIZED
  ENABLED
  QUOTA_EXCEEDED
}

input FloatOperationFilterInput {
  eq: Float
  neq: Float
  in: [Float]
  nin: [Float]
  gt: Float
  ngt: Float
  gte: Float
  ngte: Float
  lt: Float
  nlt: Float
  lte: Float
  nlte: Float
}

input HashIdFilterInput {
  and: [HashIdFilterInput!]
  or: [HashIdFilterInput!]
  eq: String
  neq: String
  in: [String]
  nin: [String]
}

type IntegrationActor implements Actor {
  actorId: ID!
  integrationType: IntegrationType!
  displayName: String!
}

type IntegrationConnection {
  links(where: IntegrationLinkFilterInput): [IntegrationLink!]!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: IntegrationType!
  status: IntegrationConnectionStatus!
  id: ID!
}

input IntegrationConnectionFilterInput {
  and: [IntegrationConnectionFilterInput!]
  or: [IntegrationConnectionFilterInput!]
  name: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  type: IntegrationTypeOperationFilterInput
  status: IntegrationConnectionStatusOperationFilterInput
  id: LongOperationFilterInput
}

enum IntegrationConnectionStatus {
  HEALTHY
  UNHEALTHY
  DELETED
}

input IntegrationConnectionStatusOperationFilterInput {
  eq: IntegrationConnectionStatus
  neq: IntegrationConnectionStatus
  in: [IntegrationConnectionStatus!]
  nin: [IntegrationConnectionStatus!]
}

type IntegrationLink {
  issue: Issue!
  createdAt: DateTime!
  updatedAt: DateTime!
  data: IssueIntegrationData!
  status: IssueIntegrationLinkStatus!
  user: User!
  connection: IntegrationConnection!
  id: ID!
}

input IntegrationLinkFilterInput {
  and: [IntegrationLinkFilterInput!]
  or: [IntegrationLinkFilterInput!]
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  data: IssueIntegrationDataFilterInput
  status: IssueIntegrationLinkStatusOperationFilterInput
  user: UserFilterInput
  connection: IntegrationConnectionFilterInput
  id: LongOperationFilterInput
}

enum IntegrationType {
  ASANA
  LINEAR
  JIRA
  SLACK
  GITHUB
  TRELLO
  MONDAY
  CLICK_UP
}

input IntegrationTypeOperationFilterInput {
  eq: IntegrationType
  neq: IntegrationType
  in: [IntegrationType!]
  nin: [IntegrationType!]
}

input IntOperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

type Issue {
  labels: [Label!]!
  data: IssueData!
  subscribers(where: UserFilterInput): [User!]!
  attachments: [Attachment!]!
  activityLog(
    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: IssueActivityLogFilterInput
  ): ActivityLogConnection
  integrationLinks(where: IntegrationLinkFilterInput): [IntegrationLink!]!
  projectId: ID!
  statusId: ID!
  userId: ID!
  assigneeId: ID
  title: String!
  description: String!
  index: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: IssueStatus! @deprecated(reason: "Use StatusV2 instead")
  priority: IssuePriority!
  captureSource: IssueCaptureSource!
  statusV2: Status!
  preview: Attachment
  commentsCount: Int!
  creator: User!
  assignee: User
  project: Project!
  labelIds: [ID]!
  id: ID!
}

type IssueActivityCreatedEvent {
  issueId: ID!
  activity: IssueActivityLog!
}

type IssueActivityDeletedEvent {
  issueId: ID!
  activityId: ID!
}

type IssueActivityLog {
  data: IssueActivityLogData!
  actor: Actor!
  timestamp: DateTime!
  activityType: IssueActivityType!
  actorId: ID!
  id: ID!
}

interface IssueActivityLogData {
  activityId: ID!
}

input IssueActivityLogFilterInput {
  and: [IssueActivityLogFilterInput!]
  or: [IssueActivityLogFilterInput!]
  timestamp: DateTimeOperationFilterInput
  activityType: IssueActivityTypeOperationFilterInput
  actorId: LongOperationFilterInput
  id: LongOperationFilterInput
}

enum IssueActivityType {
  ISSUE_CREATED
  COMMENT_ADDED
  ATTACHMENT_ADDED
  ISSUE_UPDATED
  AI_SUGGESTION
}

input IssueActivityTypeOperationFilterInput {
  eq: IssueActivityType
  neq: IssueActivityType
  in: [IssueActivityType!]
  nin: [IssueActivityType!]
}

type IssueActivityUpdatedEvent {
  issueId: ID!
  activity: IssueActivityLog!
}

type IssueAiSuggestionData implements IssueActivityLogData {
  suggestion: String!
  activityId: ID!
}

type IssueAttachmentData implements IssueActivityLogData {
  id: ID!
  type: AttachmentType!
  url: String!
  contentType: String!
  filename: String!
  activityId: ID!
}

enum IssueAttachmentStatus {
  PENDING
  PROCESSING
  PROCESSED
  FAILED
}

input IssueAttachmentStatusOperationFilterInput {
  eq: IssueAttachmentStatus
  neq: IssueAttachmentStatus
  in: [IssueAttachmentStatus!]
  nin: [IssueAttachmentStatus!]
}

enum IssueCaptureSource {
  BROWSER_EXTENSION
  WEB_APP
}

input IssueCaptureSourceOperationFilterInput {
  eq: IssueCaptureSource
  neq: IssueCaptureSource
  in: [IssueCaptureSource!]
  nin: [IssueCaptureSource!]
}

type IssueCommentData implements IssueActivityLogData {
  reactions: [Reaction!]!
  id: ID!
  richText: JSON!
  htmlText: String!
  user: User!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  edited: Boolean!
  activityId: ID!
}

enum IssueConsoleLogsType {
  LOG
  INFO
  WARN
  ERROR
  DEBUG
  ASSERT
}

type IssueCreatedData implements IssueActivityLogData {
  activityId: ID!
}

type IssueCreatedEvent {
  projectId: ID!
  userId: ID!
  issue: Issue!
}

union IssueData = IssueEmptyDataType | IssueWebData

type IssueDeletedEvent {
  userId: ID!
  projectId: ID!
  issueId: ID!
}

type IssueEmptyDataType {
  projectId: ID!
}

union IssueEvent = IssueActivityCreatedEvent | IssueActivityDeletedEvent | IssueActivityUpdatedEvent

input IssueFilterInput {
  and: [IssueFilterInput!]
  or: [IssueFilterInput!]
  assigneeId: HashIdFilterInput
  userId: HashIdFilterInput
  id: HashIdFilterInput
  projectId: HashIdFilterInput
  statusId: HashIdFilterInput
  labelIds: ListHashIdFilterInput
  title: StringOperationFilterInput
  description: StringOperationFilterInput
  index: IntOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  status: IssueStatusOperationFilterInput
  priority: IssuePriorityOperationFilterInput
  captureSource: IssueCaptureSourceOperationFilterInput
  statusV2: StatusFilterInput
  preview: AttachmentFilterInput
  commentsCount: IntOperationFilterInput
  creator: UserFilterInput
  assignee: UserFilterInput
  project: ProjectFilterInput
}

type IssueIntegrationData {
  id: String!
  url: String!
  displayId: String!
  status: String!
  completed: Boolean!
  assignee: ExternalAssignee
}

input IssueIntegrationDataFilterInput {
  and: [IssueIntegrationDataFilterInput!]
  or: [IssueIntegrationDataFilterInput!]
  id: StringOperationFilterInput
  url: StringOperationFilterInput
  displayId: StringOperationFilterInput
  status: StringOperationFilterInput
  completed: BooleanOperationFilterInput
  assignee: ExternalAssigneeFilterInput
}

enum IssueIntegrationLinkStatus {
  HEALTHY
  UNHEALTHY
  EXTERNALLY_DELETED
}

input IssueIntegrationLinkStatusOperationFilterInput {
  eq: IssueIntegrationLinkStatus
  neq: IssueIntegrationLinkStatus
  in: [IssueIntegrationLinkStatus!]
  nin: [IssueIntegrationLinkStatus!]
}

enum IssueNetworkType {
  XHR
  JS
  CSS
  IMG
  MEDIA
  FONT
  DOC
  WS
  WASM
  MANIFEST
  OTHER
}

enum IssuePriority {
  NONE
  LOW
  MEDIUM
  HIGH
  URGENT
}

input IssuePriorityOperationFilterInput {
  eq: IssuePriority
  neq: IssuePriority
  in: [IssuePriority!]
  nin: [IssuePriority!]
}

"""A connection to a list of items."""
type IssuesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [IssuesEdge!]

  """A flattened list of the nodes."""
  nodes: [Issue!]

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

enum IssueScope {
  CREATED
  SUBSCRIBED
  ASSIGNED
}

"""An edge in a connection."""
type IssuesEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Issue!
}

input IssueSortInput {
  projectId: SortEnumType
  statusId: SortEnumType
  userId: SortEnumType
  assigneeId: SortEnumType
  title: SortEnumType
  description: SortEnumType
  index: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
  status: SortEnumType
  priority: SortEnumType
  captureSource: SortEnumType
  statusV2: StatusSortInput
  preview: AttachmentSortInput
  commentsCount: SortEnumType
  creator: UserSortInput
  assignee: UserSortInput
  project: ProjectSortInput
  id: SortEnumType
}

enum IssueStatus {
  ACTIVE
  RESOLVED
  ARCHIVED
  DELETED
}

input IssueStatusOperationFilterInput {
  eq: IssueStatus
  neq: IssueStatus
  in: [IssueStatus!]
  nin: [IssueStatus!]
}

type IssueUpdatedData implements IssueActivityLogData {
  fromTitle: String
  toTitle: String
  fromDescription: String
  toDescription: String
  fromAssignee: User
  toAssignee: User
  toStatus: Status
  fromStatus: Status
  fromPriority: IssuePriority
  toPriority: IssuePriority
  addedLabels: [Label!]!
  removedLabels: [Label!]!
  activityId: ID!
}

type IssueUpdatedEvent {
  projectId: ID!
  userId: ID!
  issue: Issue!
}

type IssueWebData {
  screenshotUrl: String @deprecated(reason: "No longer supported.")
  url: String!
  pageTitle: String!
  userAgent: String!
  elements: [WebElement!]!
  path: String!
  host: String!
}

type IterationXActor implements Actor {
  actorId: ID!
  displayName: String!
}

type JiraAccessibleResource {
  cloudId: String!
  name: String!
  url: String!
  scopes: [String!]!
}

type JiraComponent {
  self: String!
  id: Int!
  name: String!
}

type JiraConnection {
  resources: [JiraAccessibleResource!]!
  projects(resourceId: String!, search: String!): [JiraProject!]!
  issueTypes(resourceId: String!, projectId: String!): [JiraIssueType!]!
  parentIssues(resourceId: String!, projectId: String!, hierarchyLevel: Int!, search: String!): [JiraIssue!]!
  sprints(resourceId: String!, projectId: String!, boardId: String!): [JiraSprint!]!
  components(resourceId: String!, projectId: String!, search: String!): [JiraComponent!]!
  assignableUsers(resourceId: String!, projectId: String!, search: String!): [JiraUser!]!
  id: ID!
}

type JiraField {
  key: String!
  name: String!
  allowedValues: [JSON!]!
}

type JiraIssue {
  id: String!
  self: String!
  key: String!
  fields: JiraIssueFields!
}

type JiraIssueFields {
  status: JiraIssueStatus!
  assignee: JiraUser
  summary: String!
  description: JsonDocument!
}

type JiraIssueStatus {
  self: String!
  name: String!
  category: JiraStatusCategory!
}

type JiraIssueType {
  self: String!
  id: String!
  name: String!
  subtask: Boolean!
  hierarchyLevel: Int!
  iconUrl: String!
  fields: [KeyValuePairOfStringAndJiraField!]!
}

type JiraProject {
  name: String!
  category: JiraProjectCategory!
  self: String!
  id: String!
  key: String!
  avatarUrls: JiraProjectAvatarUrls!
}

type JiraProjectAvatarUrls {
  url: String!
}

type JiraProjectCategory {
  self: String!
  id: String!
  name: String!
  description: String!
}

type JiraSprint {
  self: String!
  id: Int!
  name: String!
  state: String!
  originBoardId: Int!
}

type JiraStatusCategory {
  key: String!
}

type JiraUser {
  self: String!
  accountId: String!
  emailAddress: String!
  name: String!
  avatarUrls: JiraUserAvatarUrls!
}

type JiraUserAvatarUrls {
  url: String!
}

scalar JSON

type JsonDocument {
  rootElement: JSON!
}

type KeyValuePairOfStringAndJiraField {
  key: String!
  value: JiraField!
}

type KeyValuePairOfStringAndString {
  key: String!
  value: String!
}

type Label {
  id: ID!
  name: String!
  color: String!
  issueCount: Int!
}

input LabelFilterInput {
  and: [LabelFilterInput!]
  or: [LabelFilterInput!]
  id: LongOperationFilterInput
  name: StringOperationFilterInput
  color: StringOperationFilterInput
  issueCount: IntOperationFilterInput
}

type LinearConnection {
  teams: [LinearTeam!]!
  projects(teamId: String!, search: String!): [LinearProject!]!
  status(teamId: String!): [LinearStatus!]!
  assignableUsers: [LinearUser!]!
  id: ID!
}

type LinearProject {
  name: String!
  id: String!
}

type LinearStatus {
  name: String!
  id: String!
  team: LinearTeam!
}

type LinearTeam {
  name: String!
  id: String!
}

type LinearUser {
  name: String!
  id: String!
  avatarUrl: String!
}

input ListHashIdFilterInput {
  all: HashIdFilterInput
  none: HashIdFilterInput
  some: HashIdFilterInput
  any: Boolean
}

input ListIntOperationFilterInput {
  all: IntOperationFilterInput
  none: IntOperationFilterInput
  some: IntOperationFilterInput
  any: Boolean
}

"""
The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

input LongOperationFilterInput {
  eq: Long
  neq: Long
  in: [Long]
  nin: [Long]
  gt: Long
  ngt: Long
  gte: Long
  ngte: Long
  lt: Long
  nlt: Long
  lte: Long
  nlte: Long
}

"""A connection to a list of items."""
type MembersConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MembersEdge!]

  """A flattened list of the nodes."""
  nodes: [User!]

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type MembersEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: User!
}

enum MembershipRole {
  GUEST
  MEMBER
  ADMIN
}

input MembershipRoleOperationFilterInput {
  eq: MembershipRole
  neq: MembershipRole
  in: [MembershipRole!]
  nin: [MembershipRole!]
}

type Mutation {
  updateTeamSubscriptionSeats(input: UpdateTeamSubscriptionSeatsInput!): Boolean!
  createTeamInvites(input: CreateTeamInviteInput!): [TeamInvite!]!
  deleteTeamInvite(input: DeleteTeamInviteInput!): Boolean!
  acceptTeamInvite(input: AcceptTeamInviteInput!): Boolean!
  rejectTeamInvite(input: RejectTeamInviteInput!): Boolean!
  updateTeamInvite(input: UpdateTeamInviteInput!): TeamInvite!
  createWebIssue(input: CreateProjectWebIssueInput!): Issue!
  createEmptyIssue(input: CreateEmptyIssueInput!): Issue!
  updateIssue(input: UpdateIssueInput!): Issue!
  deleteIssuePreview(id: ID!): Boolean!
  deleteIssue(id: ID!): Boolean!
  createIssueComment(input: CreateIssueCommentInput!): IssueActivityLog!
  createIssueAttachment(input: CreateIssueAttachmentInput!): Attachment!
  deleteIssueAttachment(input: DeleteIssueAttachmentInput!): Boolean!
  createIssueCommentReaction(input: CreateIssueCommentReactionInput!): IssueActivityLog!
  deleteIssueCommentReaction(input: DeleteIssueCommentReactionInput!): IssueActivityLog!
  deleteIssueComment(input: DeleteIssueCommentInput!): Boolean!
  updateIssueComment(input: UpdateIssueCommentInput!): IssueActivityLog!
  deleteIssueAiSuggestion(issueId: ID!): Boolean!
  createTeamLabel(input: CreateTeamLabelInput!): Label!
  updateTeamLabel(input: UpdateTeamLabelInput!): Label!
  deleteTeamLabel(input: DeleteTeamLabelInput!): Boolean!
  createOAuthAuthorization(input: CreateOAuthAuthorizationInput!): String!
  createWebProject(input: CreateWebProjectInput!): Project!
  createProject(input: CreateProjectInput!): Project!
  updateProject(input: UpdateProjectInput!): Project!
  deleteProject(projectId: ID!): Boolean!
  updateUserProjectSettings(input: UpdateUserProjectSettingsInput!): UserProjectSettings!
  createProjectIntegrationConnection(input: CreateProjectIntegrationConnectionInput!): ProjectIntegrationConnection!
  updateProjectIntegrationConnection(input: UpdateProjectIntegrationConnectionInput!): Boolean!
  deleteProjectIntegrationConnection(input: DeleteProjectIntegrationConnectionInput!): Boolean!
  createProjectMembership(input: CreateProjectMembershipInput!): Boolean!
  deleteProjectMembership(input: DeleteProjectMembershipInput!): Boolean!
  createTeamStatus(input: CreateTeamStatusInput!): Status!
  updateTeamStatus(input: UpdateTeamStatusInput!): Status!
  deleteTeamStatus(input: DeleteTeamStatusInput!): Boolean!
  createPreSignedUrl(contentType: String!, scope: PreSignUrlScope!, filename: String! = ""): PreSignedUrl!
  createTeam(input: CreateTeamInput!): Team!
  createTeamProject(input: CreateTeamProjectInput!): Project!
  updateTeam(input: UpdateTeamInput!): Team!
  deleteTeam(id: ID!): Boolean!
  leaveTeam(teamId: ID!): Boolean!
  updateTeamMembership(input: UpdateTeamMembershipInput!): TeamMember!
  deleteTeamMembership(input: DeleteTeamMembershipInput!): Boolean!
  updateMe(input: UpdateMeInput!): Viewer!
  updateUserProfile(input: UpdateUserProfileInput!): Viewer!
  updateUserOnboarding(input: UpdateUserOnboardingInput!): Viewer!
  flushViewerActions(actionIds: [UUID!]!): Boolean!
}

input NetworkRecordInput {
  remoteAddress: String!
  requestUrl: String!
  requestMethod: String!
  statusCode: Int!
  type: IssueNetworkType!
  timestamp: DateTime!
}

type OAuthApplication {
  id: String!
  name: String!
  status: OAuthApplicationStatus!
  websiteUrl: String!
  description: String!
  iconUrl: String!
}

enum OAuthApplicationStatus {
  DRAFT
  SUBMITTED
  ACTIVE
  REJECTED
  SUSPENDED
}

input OpenGraphTagInput {
  attribute: String!
  attributeValue: String!
  content: String!
}

"""Information about pagination in a connection."""
type PageInfo {
  """
  Indicates whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more edges exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

union PaymentMethod = CardPaymentMethod

type PersonalProjectCreatedEvent {
  userId: ID!
  project: Project!
}

input PointInput {
  x: Int!
  y: Int!
}

input PreSignedBlobInput {
  preSignedUrlId: UUID!
  type: AttachmentType!
}

type PreSignedUrl {
  url: String!
  id: UUID!
  headers: [KeyValuePairOfStringAndString!]!
  expiresAt: DateTime!
}

enum PreSignUrlScope {
  ISSUE_ATTACHMENT
  TEAM_AVATAR
}

type Project {
  team: Team!
  data: ProjectData!
  members(
    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: UserFilterInput
  ): MembersConnection
  lastActiveMembers: [User!]!
  settings: UserProjectSettings!
  webIssues(url: String!, where: IssueFilterInput): [Issue!]!
  issues(
    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: IssueFilterInput
    order: [IssueSortInput!]
  ): IssuesConnection
  domains: [String!]!
  teamId: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  coverImageUrl: String
  issueCount: Int!
  webIssueCount: Int!
  memberCount: Int!
  pageCount: Int!
  id: ID!
}

input ProjectAssignableUsersInput {
  projectId: ID!
  search: String!
}

type ProjectCreatedEvent {
  teamId: ID!
  userId: ID!
  project: Project!
}

union ProjectData = ProjectWebData

type ProjectDeletedEvent {
  userId: ID!
  projectId: ID!
}

union ProjectEvent = IssueCreatedEvent | IssueDeletedEvent | IssueUpdatedEvent | ProjectMemberCreatedEvent | ProjectMemberDeletedEvent | ProjectMemberUpdatedEvent | ProjectUpdatedEvent

input ProjectFilterInput {
  and: [ProjectFilterInput!]
  or: [ProjectFilterInput!]
  teamId: HashIdFilterInput
  id: HashIdFilterInput
  name: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  coverImageUrl: StringOperationFilterInput
  issueCount: IntOperationFilterInput
  webIssueCount: IntOperationFilterInput
  memberCount: IntOperationFilterInput
  pageCount: IntOperationFilterInput
}

type ProjectIntegrationConnection {
  project: Project!
  integrationConnection: IntegrationConnection
  projectId: ID!
  connectionId: ID!
  userId: ID!
  settings: JSON!
  id: ID!
}

type ProjectMemberCreatedEvent {
  projectId: ID!
  user: User!
}

type ProjectMemberDeletedEvent {
  projectId: ID!
  userId: ID!
}

type ProjectMemberUpdatedEvent {
  projectId: ID!
  user: User!
}

input ProjectMentionableUsersInput {
  projectId: ID!
  search: String!
}

type ProjectNotificationSettings {
  issueAdded: Boolean!
  commentAdded: Boolean!
  issueAssigned: Boolean!
}

input ProjectNotificationSettingsInput {
  issueAdded: Boolean!
  commentAdded: Boolean!
  issueAssigned: Boolean!
}

"""A connection to a list of items."""
type ProjectsByUrlConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ProjectsByUrlEdge!]

  """A flattened list of the nodes."""
  nodes: [Project!]

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type ProjectsByUrlEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Project!
}

"""A connection to a list of items."""
type ProjectsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ProjectsEdge!]

  """A flattened list of the nodes."""
  nodes: [Project!]

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

enum ProjectScope {
  COLLABORATOR
  ALL
  OWNER
}

"""An edge in a connection."""
type ProjectsEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Project!
}

input ProjectSortInput {
  teamId: SortEnumType
  name: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
  coverImageUrl: SortEnumType
  issueCount: SortEnumType
  webIssueCount: SortEnumType
  memberCount: SortEnumType
  pageCount: SortEnumType
  id: SortEnumType
}

type ProjectUpdatedEvent {
  projectId: ID!
  userId: ID!
  project: Project!
}

type ProjectWebData {
  domain: String!
  faviconUrl: String
  pages: [ProjectWebPage!]!
}

type ProjectWebPage {
  path: String!
  host: String!
  title: String!
  issueCount: Int!
}

type Query {
  teamSubscriptionProrationPreview(teamId: ID!, subscriptionTier: SubscriptionTier!, seats: Int!): TeamSubscriptionProrationPreview!
  viewerIntegrationConnections(where: IntegrationConnectionFilterInput): [IntegrationConnection!]!
  asanaConnection(id: ID!): AsanaConnection!
  jiraConnection(id: ID!): JiraConnection!
  linearConnection(id: ID!): LinearConnection!
  teamInviteByInviteCode(inviteCode: ID!): TeamInvite!
  teamInvites(teamId: ID!): [TeamInvite!]!
  issues(
    scope: IssueScope!

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: IssueFilterInput
    order: [IssueSortInput!]
  ): IssuesConnection
  issue(id: ID!): Issue!
  issuesCsv(projectId: ID!): String!
  oAuthApplication(clientId: String!): OAuthApplication!
  projectIntegrationConnection(projectId: ID!): [ProjectIntegrationConnection!]!
  projects(
    scope: ProjectScope! = ALL

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: ProjectFilterInput
    order: [ProjectSortInput!]
  ): ProjectsConnection
  projectsByUrl(
    url: String!

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: ProjectFilterInput
    order: [ProjectSortInput!]
  ): ProjectsByUrlConnection
  projectsOrderedByDomains(domain: String!): [Project!]!
  project(id: ID!): Project!
  projectAssignableUsers(request: ProjectAssignableUsersInput!): [User!]!
  mentionableUsers(input: ProjectMentionableUsersInput!): [User!]!
  teams(
    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: TeamFilterInput
    order: [TeamSortInput!]
  ): TeamsConnection
  teamsForProjectCreation: [Team!]!
  team(id: ID!): Team!
  teamIssues(
    teamId: ID!

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: IssueFilterInput
    order: [IssueSortInput!]
  ): TeamIssuesConnection
  teamAssignableUsers(request: TeamAssignableUsersInput!): [User!]!
  me: Viewer!
}

type Reaction {
  users: [User!]!
  name: String!
}

input RectangleInput {
  width: Int!
  height: Int!
}

input RejectTeamInviteInput {
  inviteId: ID!
}

type RgbaColor {
  red: Int!
  green: Int!
  blue: Int!
  alpha: Float!
}

input RgbaColorFilterInput {
  and: [RgbaColorFilterInput!]
  or: [RgbaColorFilterInput!]
  red: IntOperationFilterInput
  green: IntOperationFilterInput
  blue: IntOperationFilterInput
  alpha: FloatOperationFilterInput
}

input RgbaColorSortInput {
  red: SortEnumType
  green: SortEnumType
  blue: SortEnumType
  alpha: SortEnumType
}

enum SortEnumType {
  ASC
  DESC
}

type Status {
  name: String!
  color: String!
  category: StatusCategory!
  issueCount: Int!
  order: Int!
  categoryCount: Int!
  isDefault: Boolean!
  isSystem: Boolean!
  isDeleted: Boolean!
  id: ID!
}

enum StatusCategory {
  BACKLOG
  UNSTARTED
  STARTED
  COMPLETED
  CANCELED
}

input StatusCategoryOperationFilterInput {
  eq: StatusCategory
  neq: StatusCategory
  in: [StatusCategory!]
  nin: [StatusCategory!]
}

input StatusFilterInput {
  and: [StatusFilterInput!]
  or: [StatusFilterInput!]
  name: StringOperationFilterInput
  color: StringOperationFilterInput
  category: StatusCategoryOperationFilterInput
  issueCount: IntOperationFilterInput
  order: IntOperationFilterInput
  categoryCount: IntOperationFilterInput
  isDefault: BooleanOperationFilterInput
  isSystem: BooleanOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  id: IntOperationFilterInput
}

input StatusSortInput {
  name: SortEnumType
  color: SortEnumType
  category: SortEnumType
  issueCount: SortEnumType
  order: SortEnumType
  categoryCount: SortEnumType
  isDefault: SortEnumType
  isSystem: SortEnumType
  isDeleted: SortEnumType
  id: SortEnumType
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
  trigramWordSimilarity: TrigramWordSimilarityInput
}

type Subscription {
  issue(id: ID!): IssueEvent!
  project(id: ID!): ProjectEvent!
  team(id: ID!): TeamEvent!
  me: UserEvent!
}

type SubscriptionBillingDetails {
  paymentMethod: PaymentMethod
  email: String!
  price: Long
  currency: String
}

enum SubscriptionStatus {
  ACTIVE
  OVERDUE
  CANCELED
  DELINQUENT
}

enum SubscriptionTier {
  FREE
  PRO
  ENTERPRISE
}

type Team {
  members: [TeamMember!]!
  labels(where: LabelFilterInput): [Label!]!
  statuses(where: StatusFilterInput): [Status!]!
  projects(
    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: ProjectFilterInput
    order: [ProjectSortInput!]
  ): ProjectsConnection
  subscription: TeamSubscription!
  billingPortalUrl(returnUrl: String!): String!
  subscriptionCheckoutUrl(subscriptionTier: SubscriptionTier!, returnUrl: String! = ""): String!
  availableFeatures: Features!
  invites: [TeamInvite!]!
  name: String!
  description: String!
  avatar: Avatar!
  avatarUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
  memberCount: Int!
  projectCount: Int!
  issueCount: Int!
  id: ID!
}

type TeamActor implements Actor {
  actorId: ID!
  displayName: String!
  avatar: Avatar!
  id: ID!
}

input TeamAssignableUsersInput {
  teamId: ID!
  search: String!
}

type TeamCreatedEvent {
  userId: ID!
  team: Team!
}

type TeamDeletedEvent {
  userId: ID!
  teamId: ID!
}

union TeamEvent = ProjectCreatedEvent | TeamInviteCreatedEvent | TeamInviteDeletedEvent | TeamInviteUpdatedEvent | TeamMemberCreatedEvent | TeamMemberDeletedEvent | TeamMemberUpdatedEvent | TeamSubscriptionUpdated | TeamUpdatedEvent

input TeamFilterInput {
  and: [TeamFilterInput!]
  or: [TeamFilterInput!]
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  avatar: AvatarFilterInput
  avatarUrl: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  memberCount: IntOperationFilterInput
  projectCount: IntOperationFilterInput
  issueCount: IntOperationFilterInput
  id: IntOperationFilterInput
}

type TeamInvite {
  team: Team!
  teamId: ID!
  inviter: User!
  email: String!
  role: MembershipRole!
  avatarUrl: String!
  projectIds: [ID]
  id: ID!
}

type TeamInviteCreatedEvent {
  teamId: ID!
  userId: ID!
  invite: TeamInvite!
}

type TeamInviteDeletedEvent {
  userId: ID!
  teamId: ID!
  inviteId: ID!
}

input TeamInviteFilterInput {
  and: [TeamInviteFilterInput!]
  or: [TeamInviteFilterInput!]
  teamId: IntOperationFilterInput
  inviter: UserFilterInput
  email: StringOperationFilterInput
  role: MembershipRoleOperationFilterInput
  avatarUrl: StringOperationFilterInput
  projectIds: ListIntOperationFilterInput
  id: LongOperationFilterInput
}

type TeamInviteUpdatedEvent {
  teamId: ID!
  userId: ID!
  invite: TeamInvite!
}

"""A connection to a list of items."""
type TeamIssuesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TeamIssuesEdge!]

  """A flattened list of the nodes."""
  nodes: [Issue!]

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type TeamIssuesEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Issue!
}

type TeamMember {
  user: User!
  teamId: ID!
  userId: ID!
  role: MembershipRole!
  projectIds: [ID]
  id: ID!
}

type TeamMemberCreatedEvent {
  teamId: ID!
  membership: TeamMember!
}

type TeamMemberDeletedEvent {
  teamId: ID!
  userId: ID!
}

type TeamMemberUpdatedEvent {
  teamId: ID!
  userId: ID!
  member: TeamMember!
}

"""A connection to a list of items."""
type TeamsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TeamsEdge!]

  """A flattened list of the nodes."""
  nodes: [Team!]

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

"""An edge in a connection."""
type TeamsEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Team!
}

input TeamSortInput {
  name: SortEnumType
  description: SortEnumType
  avatar: AvatarSortInput
  avatarUrl: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
  memberCount: SortEnumType
  projectCount: SortEnumType
  issueCount: SortEnumType
  id: SortEnumType
}

type TeamSubscription {
  team: Team!
  billingDetails: SubscriptionBillingDetails
  details: TeamSubscriptionDetails!
  seats: Int!
  planId: String!
  tier: SubscriptionTier!
  status: SubscriptionStatus!
  billingFrequency: BillingFrequency!
  createdAt: DateTime!
  billingCycleStartDate: DateTime!
  billingCycleEndDate: DateTime!
  cancelAt: DateTime
  canceledAt: DateTime
  id: ID!
}

type TeamSubscriptionDetails {
  issues: UsageCounter!
  videos: UsageCounter!
  labels: UsageCounter!
  statuses: UsageCounter!
  singleAttachmentSizeLimit: Int!
  totalAttachmentStorage: UsageCounter!
  autoIntegrateCapturedIssues: Boolean!
  projectPrivacy: Boolean!
  advancedCaptureIssues: Boolean!
}

type TeamSubscriptionProrationPreview {
  totalAmount: Long!
  prorationDate: DateTime!
}

type TeamSubscriptionUpdated {
  teamId: ID!
}

type TeamUpdatedEvent {
  teamId: ID!
  userId: ID!
  team: Team!
}

input TrigramWordSimilarityInput {
  text: String!
  value: Float!
}

input UpdateIssueCommentInput {
  messageId: ID!
  richText: JSON
  htmlText: String
}

input UpdateIssueInput {
  issueId: ID!
  title: String
  description: String
  status: IssueStatus
  priority: IssuePriority
  assigneeId: ID
  unassign: Boolean
  preSignedBlob: PreSignedBlobInput
  labelsIds: [ID]
  statusId: ID
}

input UpdateMeInput {
  firstName: String
  lastName: String
  avatar: Base64UploadInput
}

input UpdateProjectInput {
  projectId: ID!
  name: String
}

input UpdateProjectIntegrationConnectionInput {
  projectId: ID!
  connectionId: ID!
  settings: JSON
}

input UpdateTeamInput {
  teamId: ID!
  name: String
  description: String
  avatarPreSignedUrlId: UUID
}

input UpdateTeamInviteInput {
  inviteId: ID!
  teamId: ID!
  role: MembershipRole!
}

input UpdateTeamLabelInput {
  labelId: ID!
  teamId: ID!
  name: String
  color: String
}

input UpdateTeamMembershipInput {
  teamId: ID!
  memberId: ID!
  role: MembershipRole!
}

input UpdateTeamStatusInput {
  teamId: ID!
  statusId: ID!
  name: String
  color: String
  order: Int
  category: StatusCategory
  isDefault: Boolean
}

input UpdateTeamSubscriptionSeatsInput {
  teamId: ID!
  subscriptionTier: SubscriptionTier!
  seats: Int!
  prorationDate: DateTime
}

input UpdateUserOnboardingInput {
  webAppOnboardingStep: WebAppOnboardingStep
  chromeAppOnboarding: ChromeAppOnboarding
}

input UpdateUserProfileInput {
  kindOfWork: UserKindOfWork
  workPlace: UserWorkPlace
  collaboratorsType: UserCollaboratorsType
}

input UpdateUserProjectSettingsInput {
  projectId: ID!
  emailNotificationSettings: ProjectNotificationSettingsInput!
}

type UsageCounter {
  used: Int!
  total: Int
}

type User {
  firstName: String!
  lastName: String!
  avatar: Avatar!
  fullname: String!
  email: String!
  id: ID!
}

type UserAction {
  id: UUID!
  action: String!
  createdAt: DateTime!
  data: JSON
}

type UserActor implements Actor {
  actorId: ID!
  displayName: String!
  avatar: Avatar!
  id: ID!
}

enum UserCollaboratorsType {
  TEAMMATES
  CLIENTS
  FREELANCERS
  OTHER
}

union UserEvent = ActionCreatedEvent | IssueCreatedEvent | IssueDeletedEvent | IssueUpdatedEvent | PersonalProjectCreatedEvent | ProjectDeletedEvent | ProjectUpdatedEvent | TeamCreatedEvent | TeamDeletedEvent | TeamInviteCreatedEvent | TeamInviteDeletedEvent | TeamInviteUpdatedEvent | TeamMemberDeletedEvent | TeamMemberUpdatedEvent | TeamUpdatedEvent | UserSubscriptionUpdatedEvent

input UserFilterInput {
  and: [UserFilterInput!]
  or: [UserFilterInput!]
  firstName: StringOperationFilterInput
  lastName: StringOperationFilterInput
  avatar: AvatarFilterInput
  fullname: StringOperationFilterInput
  email: StringOperationFilterInput
  id: IntOperationFilterInput
}

enum UserKindOfWork {
  PRODUCT_MANAGEMENT
  DESIGN
  DEVELOPMENT
  USER_RESEARCH
  STUDENT
  MARKETING
  COPYWRITING
  OTHER
}

type UserOnboarding {
  webAppOnboardingStep: WebAppOnboardingStep!
  chromeAppOnboarding: ChromeAppOnboarding!
}

type UserProjectSettings {
  emailNotification: ProjectNotificationSettings!
}

input UserSortInput {
  firstName: SortEnumType
  lastName: SortEnumType
  avatar: AvatarSortInput
  fullname: SortEnumType
  email: SortEnumType
  id: SortEnumType
}

type UserSubscriptionUpdatedEvent {
  userId: ID!
}

enum UserWorkPlace {
  AGENCY
  COMPANY
  FREELANCE
  SCHOOL
  BOOTCAMP
  OTHER
}

scalar UUID

type Viewer {
  userOnboarding: UserOnboarding
  teamInvites(where: TeamInviteFilterInput): [TeamInvite!]!
  actions: [UserAction!]!
  firstName: String!
  lastName: String!
  avatar: Avatar!
  fullname: String!
  email: String!
  id: ID!
}

enum WebAppOnboardingStep {
  KIND_OF_WORK
  WORK_PLACE
  COLLABORATORS_TYPE
  TEAM_CREATION
  TEAM_INVITE
  DONE
}

type WebElement {
  tagName: String
  node: Any!
}